---
output: 
  bookdown::html_document2:
    number_sections: true
---


R Package - projects

Nikolas I. Krieger, M.S.^1^ and Jarrod E. Dalton, Ph.D.^1,2^

^1^ Department of Quantitative Health Sciences, Lerner Research Institute, Cleveland Clinic, 9500 Euclid Avenue (JJN3), Cleveland, OH, 44195
^2^ Cleveland Clinic Lerner College of Medicine, Case Western Reserve University

```{r load_libraries, echo=FALSE, message=FALSE, warning=FALSE}
library(projects)
library(tidyverse)
```

```{r load_data}

```

```{r munge_data}

```

# Abstract {-}


# Introduction

Reproducibility in research is the focus of the much debated replication crisis and is therefore an increasingly central goal of the contemporary scientific process. All research reports results by nature, but reproducible research additionally provides readers with a detailed description of the workflow that the researchers used to generate the results. Disclosing this workflow is important to the evaluation and validation of the research. If other researchers can follow the same workflow to achieve the same results, it corroborates the results as scientific knowledge. Even if the workflow fails to yield reproducible results, scientific knowledge is still advanced, as the workflow is shown not to be productive. (include something about this survey? https://www.nature.com/news/1-500-scientists-lift-the-lid-on-reproducibility-1.19970)

Whereas careful documentation is a pillar of reproducibility, pristine documentation can still yield irreproducible research if the workflow involves inaccessible instruments or tools. Fortunately, there exist tody widely available tools that aid with reproducible research, such as R and other statistical programming languages, which allow for precise documentation of some of the most detail-oriented portions of a project workflow. Researchers can distribute their code scripts alongside their results in order to communicate the integrity of their data processing and analysis. Unfortunately, statistical programming languages per se only contribute to research reproducibility insofar as individual statistical programmers are able (1) to use these tools effectively and (2) to integrate their own use of these tools with their collaborators' work---which may not be inclined to reproducibility.

The goal of the projects R package is to provide a set of tools which support an efficient project management workflow for statisticians and data scientists who perform reproducible research within team science environments. The projects package is built upon some existing tools for reproducible research, particularly RStudio, the R integrated development environment in which it dwells, and RMarkdown, the file structure that allows users to assemble datasets, perform analyses, and write manuscripts in a single file. The projects package is oriented toward efficient and reproducible academic research manuscript development, and incorporates protocol and analysis templates based on widely-accepted reporting guidelines (viz., CONSORT and STROBE). When used on a shared file system (e.g., a server), the projects package provides infrastructure for collaborative research: multiple researchers can work on the same project and keep track of its progress without having to request updates.

The primary features of the projects R package are the following:

* Relational database containing details of projects, project coauthors and their affiliations, so that author details generally need to be entered only once;
* Tools for editing metadata associated with projects, authors and affiliations;
* Automated file structure supporting reproducible research workflow;
* Report templates which automatically generate title page headers, including a numbered author list and corresponding affiliations;
* Full RStudio integration via RMarkdown, including customizable styling via cascading style sheets (CSS); 
* Customization, including the ability to add templates for protocols and reports, and the ability to change default project directory and file structures; and
* Organization and management functionality, including the ability to group, archive, and delete projects.

# Conceptual Framework

[workflow figure]

Whereas researchers of different disciplines may operate in nuanced ways, there is an assumed project workflow common to all research. Studies are conceptualized and designed: a protocol is constructed in order to focus the research questions and their subsequent investigation. Data are collected in order to answer the research questions, and they are subsequently manipulated and tidied in order to make data analysis possible. The results of the analyses are compiled into a report, and ultimately an academic manuscript is drafted and submitted for wider distribution.

When navigating this workflow, researchers strive for reproducibility wherever possible, but especially during the intermediate, data-focused phases of the workflow. Readers of the final manuscript should have access to the study data in its most unrefined state possible: a frozen dataset. A frozen dataset is almost invariably a digital file or set of files that standard data analysis software can process. Whereas study data may have been initially collected in a non-digital manner, a frozen data set represents the study data's earliest state of simultaneous digitization and consolidation From this point through the reporting stage, total reproducibility is expected. Thanks to modern data analysis via statistical programming languages, a reader should be able to exactly reproduce all data-derived results from the frozen data set alone. With access to the exact scripts the researchers used to produce their results, readers can scrutinize every function call performed on the frozen data set and its descendents.

The middle stage of the assumed study workflow can be performed with near perfect reproducibility, but the beginning and ending stages may not. Researchers cannot document every thought process, literature probe, and informal conversation that contributes to the development of the initial study protocol, but they should strive to document it as meticulously as possible. As for the final stages of project development, journals require that manuscripts adhere to arbitrary stylistic guidelines and that they be digitally submitted with file types that are not independently conducive to reproducibility (e.g., .pdf). For instance, even as RStudio supports the creation of submission-ready documents directly from frozen datasets, the vast majority of project teams include experts who do not use RStudio; therefore, the collaborative manuscript editing process ultimately takes place in an environment (e.g., Microsoft Word) that only supports total reproducibility with extraordinary effort. In light of these realities, researchers must do their best during manuscript creation, keeping the process in reproducible environments for as long as possible and otherwise documenting significant changes and alterations.

At its outset, the projects package creates a "projects" folder where all research projects will reside. The "projects" folder will also contain a relational database of the research projects and the persons who contribute to them. The database allows for users to input important metadata about the projects and authors, including stage of research and contact information. Once this higher-level folder is created, users run R functions to create projects, each of which is given its own folder. New project folders automatically include aptly named subfolders and templates in order to guide the project workflow (e.g., a "data" subfolder and a "datawork" RMarkdown file template). Right away, users can begin working on the research project and edit the metadata of the project itself and its authors. To lessen the burden of the mundane details of manuscript writing, the projects package can output lines to the console that, when copied into an RMarkdown file, generates a title page with all relevant authorship information of any given project. Finally, since users may create dozens of projects over time, users can run functions to organize their projects within grouping subfolders of the main "projects" folder. 

# The projects package

## Installation

The projects R package is currently available on Github. It can be installed with

```{r install_github, eval=FALSE}
devtools::install_github("NikKrieger/projects")
```

## Initial Setup 

All projects that the user creates with the projects package---as well as its infrastructure---reside in a main folder called "projects". Users need not manually create this directory, and in fact they are encouraged not to manually manipulate any folders that the projects package involves. Instead, users run the function `setup_projects()`, providing the full file path of the directory in which the user wants the "projects" folder to reside.

## Metadata

Data about authors, institutional and/or department affiliations and projects are stored in .rds files within the main project directory, so that the user only needs to enter these details once (unless, for example, a co-author changes their name or affiliations). These data are also used to assemble title pages of reports, with automatically generated author lists and lists of author affiliations. We provide a complete example of this process below in Section \@ref(demo).

The main metadata tables accessible to the user are `projects`, `authors` and `affiliations`, via functions thusly named. Two additional tables are internally created to keep track of associations between authors and projects and between authors and affiliations (see \@ref(assoc)).

### Projects Table Columns

* `id` -- an identification number, specifically an integer, unique among the other projects. This number can be used whenever needing to identify this project within `projects` package functions.
* `title` -- the title of the project. A nonambiguous substring of `title` (i.e., a substring that does not match any other project) can be used whenever needing to identify this project within `projects` package functions. This value is also printed in the YAML header of the "protocol" and "report" Rmd templates that are automatically generated upon project creation.
* `short_title` -- an optional unique nickname for the project. A nonambiguous substring of `short_title` (i.e., a substring that does not match any other project) can be used whenever needing to identify this project within `projects` package functions. This is useful if users cannot remember the long, formal project `title` nor the project `id`.
* `current_owner` -- the `id` of the author who is responsible for taking action in order that work on the project may proceed further.
* `creator` -- the `id` of the author who initially created the project (i.e., the author who ran `new_project()`, unless this field was edited with `edit_project()` after the project's creation).
* `corresp_auth` -- the `id` of the author who should be contacted for any correspondence relating to the project. This author's name will be especially marked on automatically generated title pages for this project, and his or her contact information will be especially displayed there as well in a "Corresponding Author" section.
* `stage` -- one of six predefined stages of project development that the project is currently in: "design," "data collection," "analysis," "manuscript," "under review," and "accepted."
* `deadline_type` -- a simple description of the meaning of the date contained in the next field, `deadline`.
* `deadline` -- a date indicating some kind of deadline whose meaning is described in the previous field, `deadline_type`.
* `status` -- a short description of the status of the project. For example, it may elaborate on the value of `stage` and/or `current_owner`.
* `path` -- the full file path where the project folder is located.

### Authors Table

* `id` -- an identification number, specifically an integer, unique among the other authors. This number can be used whenever needing to identify this author within `projects` package functions. 
* `given_names` -- the given name or names of the author. A nonambiguous substring of `given_names` (i.e., a substring that does not match any other author) can be used whenever needing to identify this author within `projects` package functions. This is included in the automatically generated title pages of the projects associated with this author.
* `last_name` -- the last name or names of the author. A nonambiguous substring of `last_name` (i.e., a substring that does not match any other author) can be used whenever needing to identify this author within `projects` package functions. This is included after `given_names` in the automatically generated title pages of the projects associated with this author.
* `title` -- the job title of the author.
* `degree` -- the abbreviation of the author's academic degree or degrees. This is included after `last_name` in the automatically generated title pages of the projects associated with this author.
* `email` -- the email address of the author. This is included in the "Corresponding Author" section of the automatically generated title pages of projects whose `corresp_auth` field contains this author.
* `phone` -- the phone number of the author. This is included in the "Corresponding Author" section of the automatically generated title pages of projects whose `corresp_auth` field contains this author.
* `default` -- a binary field indicating whether or not the `projects` package should treat this author as the "default author." Only one author can be the default author per computer. The default author's `id` is automatically inserted in the `creator` field of new projects if user does not specify a different author.

### Affiliations Table

* `id` -- an identification number, specifically an integer, unique among the other affiliations. This number can be used whenever needing to identify this affiliation within `projects` package functions.
* `department_name` -- the department name of the affiliation. A nonambiguous substring of `department_name` (i.e., a substring that does not match any other affiliation) can be used whenever needing to identify this affiliation within `projects` package functions. This is included in the affiliations section of the automatically generated title page of projects associated with authors with this affiliation. 
* `institution_name` -- the name of the overall institution of the affiliation. A nonambiguous substring of `institution_name` (i.e., a substring that does not match any other affiliation) can be used whenever needing to identify this affiliation within `projects` package functions. This is included after `department_name` in the affiliations section of the automatically generated title page of projects associated with authors with this affiliation.
* `address` -- the address of the affiliation. This is included after `institution_name` in the affiliations section of the automatically generated title page of projects associated with authors with this affiliation. It is also included in the "Corresponding Author" section of the title page when a project's corresponding author has this affiliation as his or her primary affiliation.

### Internal Tables {#assoc}

In keeping with relational database theory, there are two .rds files that keep track of the many-to-many relationships between projects and authors and between authors and affiliations. Each has two columns, `id1` and `id2`, that contain the `id` numbers of these items. Each row of this table describes an association. Furthermore, the `projects` package keeps track of the order in which these associations appear so that the automatically generated title pages list authors and affiliations in the correct order. Users are able to run functions to reorder these associations as needed.

## Project File Structure

Users create individual project folders with the function `new_project()`. The name of each project folder is of the form p*XXXX*, where *XXXX* is the project's `id` padded with 0s on the left side. When a project folder is created, it is automatically populated with folders and files as shown below:

* /p*XXXX*/
    + /data/
    + /data_raw/
    + /figures/
    + /manuscript/
    + /progs/
        * 01_protocol.Rmd
        * 02_datawork.Rmd
        * 03_analysis.Rmd
        * 04_report.Rmd
  + p*XXXX*.Rproj
  
The included subfolders serve to organize the project, while the .Rmd files are templates that facilitate the user's workflow.

## File Management

"we want to convey that the goal of the packacge is a compreh set of tools for managing project files and do so in a way that is self-contained in R"
"manage projects in a way that is independent of the underlying operating system."
"you usually need to make, move, copy, delete, archive files"
warning: best not to manipulate

- function call
- what happens when new_project() is called
- Project structure
   > detailed description of the sub-directories, files created, how they're automatically generated, etc.

Project Metadata Manipulation
- helper functions (e.g., set_title(), etc.) - maybe a table of these functions

Project Management Tools
- prioritization
- hot potato
- dashboards (automatically-generated e-mail reports with project status table?)
  > could do a table for the whole team and analyst-specific tables

# Customization

- CSS styles
- 

# Demonstration {#demo}

Upon installation, the `projects` package must be set up using `setup_projects()`. The user is to input the file path of the directory wherein the "projects" folder is to be located.

```{r setup_proj2, eval = FALSE}
library(projects)
setup_projects("/main_server/seymourjc")
```

```{r setup_proj, include = FALSE}
library(projects)
setup_projects("/home/kriegen/Projects/projects/test/projects",
               overwrite = TRUE)
```

```{r fake_message, echo = FALSE}
message('"projects" folder created at\n', "/main_server/seymourjc",
        '\n\nAdd affiliations with ', 'new_affiliation(), then add authors ',
        'with new_author(), then create projects with new_project()')
```

As the message suggests, it is in the user's best interest to add affilliations, followed by authors and projects.

```{r affiliation1}
new_affiliation(department_name  = "Department of Physics",
                institution_name = "University of North Science",
                address = "314 Planck Blvd, Springfield CT 06003")
```

This affiliation has been successfully added to the "affiliations" table in the `projects` relational database. The next code chunk creates a few more affiliations (output not included)

```{r affiliation2}
new_affiliation(department_name  = "Impossibles Investigation Team",
                institution_name = "Creekshirebrook Academy of Thinks",
                address = "Let Gade 27182, 1566 Copenhagen, Denmark")
new_affiliation(department_name  = "Statistical Consulting Unit",
                institution_name = "Creekshirebrook Academy of Thinks",
                address = "196 Normal Ave, Columbus, OH ")
```


* Make some authors and affiliations. Do both for one person. Then, some lines of code that complete the other 4-5 people. Then show what the authors() and affiliations() tables look like.

* Make a project, explore its contents

* Make some other projects, then show the projects() tibble.

* Demonstrate edit_*. 1) edit_author to add an affiliation; 2) edit_project to change/reorder authors. Note that the header is automatically changed.

* header() - describe potential use case - changed author name or affiliation...

* Creating project groups.

* Copying, deleting, moving and archiving projects


# Conclusions

Short and sweet.
